CVS
Funcionamento
CVS utiliza uma arquitetura cliente-servidor: um servidor armazena a(s) versão atual do projeto e seu histórico, e os clientes se conectam a esse servidor para obter uma cópia completa do projeto, trabalhar nessa cópia e então devolver suas modificações. Tipicamente, cliente e servidor devem estar conectados por uma rede local de computadores, ou pela Internet, mas o cliente e o servidor podem estar na mesma máquina se a configuração do CVS for feita de maneira a dar acesso a versões e histórico do projeto apenas a usuários locais. O servidor geralmente roda sistema ao estilo Unix, enquanto o cliente CVS pode rodar qualquer sistema operacional.
Vários clientes podem editar cópias do mesmo projeto de maneira concorrente. Quando eles confirmam suas alterações, o servidor tenta fazer uma fusão delas. Se isso não for possível, por exemplo porque mais de um cliente tentou executar alterações na mesma linha do documento, o servidor apenas executa a primeira alteração e informa ao responsável pela segunda alteração que houve conflito, e que é necessário uma intervenção humana. Se a validação da alteração for bem sucedida, o número de versão de cada cliente arquivo envolvido é incrementado, e o servidor CVS escreve uma linha de observação (fornecida pelo usuário), a data e o autor das alterações em seus arquivos de log.
Clientes podem comparar diferentes versões de um arquivo, pedir um histórico completo das alterações, ou baixar uma determinada versão do projeto, ou de uma data específica, não necessariamente a versão mais atual. Muitos projetos de código aberto permitem acesso para leitura anônimo, o que significa que qualquer pessoa pode baixar ou comparar versões sem necessidade de autenticação; somente para salvar mudanças é necessário informar a senha nesses casos.
Clientes também podem usar o comando "update" para manter suas cópias locais atualizadas com a última versão do servidor. Isso elimina a necessidade de se fazer diversos downloads de todo o projeto.
O CVS usa compressão delta para armazenar de maneira eficiente diferentes versões de um mesmo arquivo.
- Conexão direta com autenticação por usuário e senha: usuários de um repositório precisam fornecer um
login e uma senha para obter informações, fazer commits, atualizações etc. Embora este controle de acesso seja relativamente comum, é um tanto inseguro, pois as informações (incluindo login e senha) trafegam sem cripto-grafia pela rede, portanto passíveis de serem obtidas e analisadas por alguém mal-intencionado.
Terminologia
A terminologia do CVS considera um projeto (conjunto de arquivos relacionados) gerenciados pelo CVS como um módulo, que consiste em uma hierarquia de diretórios contendo os arquivos do projeto. Um servidor CVS pode gerenciar diversos módulos; ele armazena todos os módulos administrados por ele em seu repositório. 
A cópia do módulo que foi baixada para um cliente é chamada cópia de trabalho (ou checkout).
Abaixo, estão listados alguns termos em inglês, que fazem parte da terminologia CVS, e seu significado:
Checkout: normalmente é usado para denominar o primeiro download de um módulo inteiro a partir do repositório CVS.
Commit: envio das modificações feitas pelo usuário ao repositório CVS.
Export: é o download de um módulo inteiro a partir de um repositório CVS, sem os arquivos administrativos CVS. Módulos exportados não ficam sob controle do CVS.
Import: geralmente é usado para designar a criação de um módulo inteiro dentro de um repositório CVS através do upload de uma estrutura de diretórios.
Module: é uma hierarquia de diretórios. Geralmente um projeto de software existe como um simples módulo dentro do repositório.
Release: é a versão de um produto inteiro.
Revision: é a numeração atribuída pelo CVS a cada modificação de um arquivo.
Tag: é um nome simbólico dado para um conjunto de arquivos em um instante específico durante o desenvolvimento.
Branch: é uma ramificação no desenvolvimento, usada para descrever o processo de divisão dos arquivos de um projeto em linhas de desenvolvimento independentes. Podendo servir para teste de uma nova funcionalidade ou para projetos destinados a um cliente específico.
Update: atualização da cópia local do trabalho através do download das modificações feitas por outros usuários no repositório.
Merge: é a fusão de modificações feitas por diferentes usuários na cópia local de um mesmo arquivo. Sempre que alguém altera o código, é necessário realizar um update antes do commit, de modo que seja feito o merge — ou a fusão — das mudanças.
História
O CVS foi desenvolvido de uma versão anterior de um sistema chamado Revision Control System (RCS), ainda em uso, que gerencia versões de um único arquivo, mas não de projetos inteiros. Dick Grune escreveu algumas breves notas históricas sobre o CVS em seu sítio. Citando-o:
Criei o CVS para poder cooperar com meus alunos Erik Baalbergen e Maarten Waage no ACK (Amsterdam Compiler Kit) Compilador C. Cada um de nós tinha uma rotina diferente (um dos alunos trabalhava 45h por semana, outro era irregular e eu podia trabalhar no projeto apenas à noite). O projeto deles durou de Julho de 1984 até Agosto de 1985. O CVS foi chamado inicialmente de CMT, pela razão óbvia que nos permitia validar (commit) versões independentemente.
O código foi lançado publicamente ao mod.sources em 23 de junho de 1986. Ainda se pode ver a mensagem original em grupos do Google.
O código que evoluiu para a versão atual do CVS foi iniciada por Brian Berliner em abril de 1989, com posterior contribuição de Jeff Polk e muitos outros contribuidores. Brian Berliner escreveu um artigo apresentando suas contribuições para o CVS, que descreve como a ferramenta foi estendida e usada internamente pelo Prisma, uma equipe de desenvolvimento que trabalhava no núcleo do SunOS, e foi lançada em benefício da comunidade sob a GPL.
Atualmente, o código do CVS é mantido por um grupo de voluntários.
O relacionamento entre o CVS e o projeto GNU pode parecer de certa forma ambígua: o sítio do GNU distribui o programa, chamando-o de "pacote GNU", em uma página, e de "projeto licenciado pela GPL" em outra. No repositório FTP, o programa fica no diretório /non-gnu/.

Limitações
Os arquivos em um repositório CVS não podem ser renomeados a partir do cliente, eles devem ser explicitamente removidos e readicionados. Entretanto, com acesso ao servidor os arquivos podem ser renomeados. No servidor, cada arquivo na estrutura de diretório do cliente possui um equivalente seguido de,v. Exemplo: o arquivo index.html no cliente é gravado no servidor como index.html,v. A ação de renomear no servidor gera no cliente um processo de exclusão do arquivo antigo e criação de um novo e o histórico de atualizações é mantido.
O protocolo do CVS não permite que os diretórios sejam movidos ou renomeados. Cada arquivo do subdiretório em questão deve ser individualmente removido e readicionado.
Não permite "checkout" reservados (permite que dois usuários alterem o mesmo arquivo ao mesmo tempo) e em alguns casos pode ser mais custoso resolver o conflito do que evitar que ele ocorra.
Alguns dos principais desenvolvedores que trabalharam no CVS são atualmente responsáveis pelo Subversion (SVN), lançado no começo de 2004 e cujo objetivo é substituir o CVS ao lidar com algumas de suas limitações.

ViewCVS -é uma ferramente OpenSource que serve como interface de navegação para controlar repositório.
Ele apresenta em formato HTML, os diretórios, revisões, branches e log de mudanças. Algumas de suas
funcionalidades são:
- independência de repositório: o ViewCVS é capaz de acessar tanto repositórios CVS quanto repositórios
Subversion;
- Suporte para configuração individual de host virtual;
- Capacidade de rodar como um script CGI ou como um servidor autonômo


APLICAÇÃO
S.O.
SOFTWARE LIVRE
LinCVS
Windows/*nix
Sim
WinCVS
Windows
Sim
MacCVS
Mac OS
Sim
Tipos de SCV: Centralizado vs. Descentralizado.
Podemos separar os sistemas de controle de versão em 2 tipos básicos, de acordo com a maneira como
eles gerenciam seu repositório: centralizado e descentralizado. Nos SCVs centralizados as mudanças são feitas para
um servidor central único, ao passo que nos SCVs descentralizados, os desenvolvedores trabalham diretamente no
seu repositório.
É possível afirmar, também, que SCVs descentralizados utilizam um enfoque "ponta-a-ponta", ao passo
que SCVs centralizados utilizam um método "cliente/servidor".
Centralizado: vantagens e desvantagens
Os SCVs centralizados, apesar de terem um funcionamento muito mais simples que os SCVs
descentralizados, oferecem algumas características interessantes em relação aos seus concorrentes descentralizados,
muitas delas dizem respeito a sua própria simplicidade e facilidade de centralizar os dados e controlar um único
repositório. 
Como o próprio nome diz, os SCVs centralizados mantém as informações referentes aos arquivos em um
repositório único, acessível (dentro de um determinado contexto de segurança específico ao SCV em questão) a
todos os desenvolvedores de um projeto. Pode-se dizer que os SCVs centralizados utilizam uma arquitetura
Cliente/Servidor.
Em um SCV centralizado, cada desenvolvedor mantém uma cópia dos arquivos contidos no repositório,
além de alguns metadados referentes a estes arquivos, que são utilizados para "cruzar" com as informações existentes
no repositório. Ao efetuar uma mudança em um arquivo qualquer, o desenvolvedor atualiza o repositório, tornando
publicas suas alterações, através de um processo conhecido como "commit".
Adicionalmente a isto é importante ressaltar a facilidade de controlar o acesso em um SCVs centralizado
devido ao fato de as informações estão localizadas em apenas um repositório.Devido à própria simplicidade inerente à sua implementação, os SCVs centralizados tem algumas
desvantagens em relação aos descentralizados, desta maneira tornando-os pouco indicados para ambientes mais
complexos, ou aonde os desenvolvedores encontram-se "espalhados" geograficamente e não exista uma conexão
estável e permanente com o repositório de dados. Desta maneira, pode-se dizer que os SCVs centralizados são
extremamente dependentes do repositório que contém os dados, de tal maneira que um desenvolvedor não pode
sequer requisitar informações de um determinado arquivo se não existir uma conexão com o repositório, embora isto
não o impeça de continuar editando os arquivos..
Apesar de o fato de existir apenas um repositório seja vantajoso quando relacionado ao controle de
acesso, isto pode ser um problema se não existir uma política de backup séria e confiável. É importante ressaltar,
porém, que a identificação da melhor forma de backup (incremental, completo, etc) para um repositório de dados de
um SCV é variável de acordo com a maneira como o SCV armeza os arquivos e seus metadados, pois alguns SCVs
se utilizam de bancos de dados para manter suas informações ao passo que outros se utilizam de uma árvore de
arquivos logicamente ordenada para este fim.
