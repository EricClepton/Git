CVS
Funcionamento
CVS utiliza uma arquitetura cliente-servidor: um servidor armazena a(s) versão atual do projeto e seu histórico, e os clientes se conectam a esse servidor para obter uma cópia completa do projeto, trabalhar nessa cópia e então devolver suas modificações. Tipicamente, cliente e servidor devem estar conectados por uma rede local de computadores, ou pela Internet, mas o cliente e o servidor podem estar na mesma máquina se a configuração do CVS for feita de maneira a dar acesso a versões e histórico do projeto apenas a usuários locais. O servidor geralmente roda sistema ao estilo Unix, enquanto o cliente CVS pode rodar qualquer sistema operacional.
Vários clientes podem editar cópias do mesmo projeto de maneira concorrente. Quando eles confirmam suas alterações, o servidor tenta fazer uma fusão delas. Se isso não for possível, por exemplo porque mais de um cliente tentou executar alterações na mesma linha do documento, o servidor apenas executa a primeira alteração e informa ao responsável pela segunda alteração que houve conflito, e que é necessário uma intervenção humana. Se a validação da alteração for bem sucedida, o número de versão de cada cliente arquivo envolvido é incrementado, e o servidor CVS escreve uma linha de observação (fornecida pelo usuário), a data e o autor das alterações em seus arquivos de log.
Clientes podem comparar diferentes versões de um arquivo, pedir um histórico completo das alterações, ou baixar uma determinada versão do projeto, ou de uma data específica, não necessariamente a versão mais atual. Muitos projetos de código aberto permitem acesso para leitura anônimo, o que significa que qualquer pessoa pode baixar ou comparar versões sem necessidade de autenticação; somente para salvar mudanças é necessário informar a senha nesses casos.
Clientes também podem usar o comando "update" para manter suas cópias locais atualizadas com a última versão do servidor. Isso elimina a necessidade de se fazer diversos downloads de todo o projeto.
O CVS usa compressão delta para armazenar de maneira eficiente diferentes versões de um mesmo arquivo.
- Conexão direta com autenticação por usuário e senha: usuários de um repositório precisam fornecer um
login e uma senha para obter informações, fazer commits, atualizações etc. Embora este controle de acesso seja relativamente comum, é um tanto inseguro, pois as informações (incluindo login e senha) trafegam sem cripto-grafia pela rede, portanto passíveis de serem obtidas e analisadas por alguém mal-intencionado.
Terminologia
A terminologia do CVS considera um projeto (conjunto de arquivos relacionados) gerenciados pelo CVS como um módulo, que consiste em uma hierarquia de diretórios contendo os arquivos do projeto. Um servidor CVS pode gerenciar diversos módulos; ele armazena todos os módulos administrados por ele em seu repositório. 
A cópia do módulo que foi baixada para um cliente é chamada cópia de trabalho (ou checkout).
Abaixo, estão listados alguns termos em inglês, que fazem parte da terminologia CVS, e seu significado:
Checkout: normalmente é usado para denominar o primeiro download de um módulo inteiro a partir do repositório CVS.
Commit: envio das modificações feitas pelo usuário ao repositório CVS.
Export: é o download de um módulo inteiro a partir de um repositório CVS, sem os arquivos administrativos CVS. Módulos exportados não ficam sob controle do CVS.
Import: geralmente é usado para designar a criação de um módulo inteiro dentro de um repositório CVS através do upload de uma estrutura de diretórios.
Module: é uma hierarquia de diretórios. Geralmente um projeto de software existe como um simples módulo dentro do repositório.
Release: é a versão de um produto inteiro.
Revision: é a numeração atribuída pelo CVS a cada modificação de um arquivo.
Tag: é um nome simbólico dado para um conjunto de arquivos em um instante específico durante o desenvolvimento.
Branch: é uma ramificação no desenvolvimento, usada para descrever o processo de divisão dos arquivos de um projeto em linhas de desenvolvimento independentes. Podendo servir para teste de uma nova funcionalidade ou para projetos destinados a um cliente específico.
Update: atualização da cópia local do trabalho através do download das modificações feitas por outros usuários no repositório.
Merge: é a fusão de modificações feitas por diferentes usuários na cópia local de um mesmo arquivo. Sempre que alguém altera o código, é necessário realizar um update antes do commit, de modo que seja feito o merge — ou a fusão — das mudanças.
História
O CVS foi desenvolvido de uma versão anterior de um sistema chamado Revision Control System (RCS), ainda em uso, que gerencia versões de um único arquivo, mas não de projetos inteiros. Dick Grune escreveu algumas breves notas históricas sobre o CVS em seu sítio. Citando-o:
Criei o CVS para poder cooperar com meus alunos Erik Baalbergen e Maarten Waage no ACK (Amsterdam Compiler Kit) Compilador C. Cada um de nós tinha uma rotina diferente (um dos alunos trabalhava 45h por semana, outro era irregular e eu podia trabalhar no projeto apenas à noite). O projeto deles durou de Julho de 1984 até Agosto de 1985. O CVS foi chamado inicialmente de CMT, pela razão óbvia que nos permitia validar (commit) versões independentemente.
O código foi lançado publicamente ao mod.sources em 23 de junho de 1986. Ainda se pode ver a mensagem original em grupos do Google.
O código que evoluiu para a versão atual do CVS foi iniciada por Brian Berliner em abril de 1989, com posterior contribuição de Jeff Polk e muitos outros contribuidores. Brian Berliner escreveu um artigo apresentando suas contribuições para o CVS, que descreve como a ferramenta foi estendida e usada internamente pelo Prisma, uma equipe de desenvolvimento que trabalhava no núcleo do SunOS, e foi lançada em benefício da comunidade sob a GPL.
Atualmente, o código do CVS é mantido por um grupo de voluntários.
O relacionamento entre o CVS e o projeto GNU pode parecer de certa forma ambígua: o sítio do GNU distribui o programa, chamando-o de "pacote GNU", em uma página, e de "projeto licenciado pela GPL" em outra. No repositório FTP, o programa fica no diretório /non-gnu/.

